# 数据结构(青岛大学王卓老师)



## 数据结构的基本概念

![](.\images\1_2.png)

### 第一章



#### 前言

数据结构在计算机学科中的地位——核心

![](.\images\1_3.png)



**"程序=数据结构+算法"**

课程特点：概念性强，抽象。算法灵活，不易掌握。

学习建议：1.勤于思考、2.多做练习、3.多上机、4.善于寻求帮助，5.不怕困难



#### 1.1.数据结构的研究内容

计算机解决问题的步骤：

1.**具体问题抽象为数学模型**：实质：分析问题、提取操作对象、找出操作对象之间的关系、用数学语言来进行描述(数据结构)

2.**设计算法**

3.**编程、调试、运行**

![](.\images\1_5.png)



#### 1.2.基本概念和定义

##### 1.数据(data)

定义：是能输入计算机且能被计算机处理的各种符号的集合

1.信息的载体

2.对客观事物符号化的表示

3.能够被计算机识别、储存和加工

数据分类：1.数值型的数据：整形等等  2.非数值型数据：文字、图表等等



##### 2.数据元素(Data element)和数据项

数据元素：数据的基本单元，在计算机程序中通常作为一个整体进行考虑和理解，有时简称为元素，或记录、结点或顶点

数据项：构成数据元素的不可分割的最小单位。

**数据>数据元素>数据项**

eg:学生表>个人纪录>学号、姓名。。。

![](.\images\2_2.png)



##### 3.数据对象(Data Project)

数据对象：是性质相同的数据元素的集合，是数据的一个子集

eg:整数数据对象是集合N={0,+1,-1...}

字母字符数据对象是集合C={'A'、'B'、。。。、'Z'}

##### 数据元素和数据对象的关系

数据元素——**组成数据的基本单位**

与数据的关系：集合的个体

数据对象——**性质相同的数据元素的集合**

与数据的关系是:集合的子集



##### 3.数据结构

1.数据元素不是孤立存在的，它们之间存在着某种特定关系，数据元素相互之间的关系称为结构

2.是指相互之间存在一种或多种特定关系的数据元素集合

3.也可称为带结构的数据元素的集合



##### 4.数据结构（Data Structure)

1.数据元素之间的逻辑关系，也称为**逻辑结构**。

2.数据元素及其关系在计算机内存中的表示(又称为映像)，称为数据的**物理结构**或数据的**存储结构**。

3.数据的**运算和实现**，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现。



##### 5.数据结构的两个层次

**逻辑结构**

- 描述数据元素之间的逻辑关系
- 与数据的存储无关，独立于计算机
- 是从具体问题抽象出来的数学模型



**物理结构(存储结构)**

- 数据元素及其关系在计算机存储器中的结构(存储方式)
- 是数据结构在计算机中的表示



**逻辑结构与存储结构的关系**

- 存储结构是逻辑关系的映像与元素本身的映像。
- 逻辑结构是数据结构的抽象，存储结构是数据结构的实现。
- 两者综合起来建立了数据元素之间的结构关系。

**逻辑结构的种类**：

*划分方法一*

(1)线性结构

有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。

eg:线性表、栈、队列、串

![](.\images\2_3.png)

(2)非线性结构

一个结点可能有多个直接前趋和直接后继。

eg:树、图

![](.\images\2_4.png)

![](.\images\2_1.png)



*划分方式——四类基本逻辑结构*

(1)集合结构：结构中的数据元素之间除了同属于一个集合的关系外，无任何其它关系。

(2)线性结构：结构中的数据元素之间存在着一对一的线性关系。

(3)树形结构：结构中的数据元素之间存在着一对多的层次关系。

(4)图状结构或网状结构：结构中的数据元素之间存在着多对多的任意关系。

![](.\images\2_6.png)



**存储结构**：

- 顺序存储结构(重点)
- 链式存储结构(重点)
- 索引存储结构
- 散列存储结构

**1.顺序存储结构：**

- 用一种连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示。
- C语言中用数组来实现顺序存储结构。

![](.\images\2_7.png)



**2.链式存储结构**

- 用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示。
- C语言中用指针来实现链式存储结构

例：（bat,cat,eat,......,mat)

![](.\images\2_8.png)

![](.\images\2_9.png)

在存储了每一个元素的本身还存储了每一个元素的地址



**3.索引存储结构**

- 在存储结点信息的同时，还建立附加的**索引表**

  ![](.\images\2_11.png)

  ![](.\images\2_10.png)



**4.散列存储结构**

![](.\images\2_12.png)



##### 6.数据类型和抽象数据类型

在使用高级程序设计语言编写程序时，必须对程序中出现的每个变量、常量或表达式，明确说明它们所属的数据类型。

eg:在C语言中：

- 提供int,char,float,double等基本数据类型
- 数组，结构，共用体，枚举等构造数据类型
- 还有指针，空(void)类型
- 用户也可用typedef自己定义数据类型

- 一些最基本数据结构可以用数据类型来实现，如数组、字符串等；

- 而另一些常用的数据结构，如栈、队列、树、图等，不能直接用数据类型来表示。

高级语言中的数据类型明显地或隐含地规定了在程序执行期间变量和表达的所有可能的取值范围，以及在这些数值范围上所允许进行的操作。

数据类型的作用：1.约束变量或常量的**取值范围**、2.约束变量或常量的**操作**



**1.数据类型(Data Type)**

定义：**数据类型**是一组性质相同的**值的集合**以及定义于这个值集合上的**一组操作**的总称。

**2.抽象数据类型（Abstract Data Type,ADT)**

定义：**是指一个数学模型以及定义在此数学模型上的一组操作。**

- 由用户定义，从问题抽象出**数据模**型（逻辑结构）
- 还包括定义在数据模型上的一组**抽象运算**（相关操作）
- 不考虑计算机内的具体存储结构与运算的具体实现算法

eg:1.看到了圆

![](.\images\2_13.png)

抽象出圆，而忽略其颜色等

![](.\images\2_14.png)

2.看到了复数，抽象出了复数（实部，虚部）

![](.\images\2_15.png)

抽象数据类型的形式定义：

抽象数据类型可用**（D,S,P）**三元组表示

其中：

- D是数据对象
- S是D上的关系集；
- P是对D的基本操作集。

```
一个抽象数据类型的定义格式如下：
ADT 抽象数据类型名{
	数据对象:<数据对象的定义>
	数据关系:<数据关系的定义>
	基本操作:<基本操作的定义>
}ADT 抽象数据类型名

其中：
1.数据对象、数据关系的定义用伪代码描述
2.基本操作的定义格式为：
	- 基本操作名（参数表）
	- 初始条件：<初始条件描述>
	- 操作结果：<操作结果描述>
3.基本操作定义格式说明：
	1.参数表：
	赋值参数只为操作提供输入值。
	引用参数以&开头，除可提供输入值外，还将返回操作结果。
	2.初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空，则省略之。
	3.操作结果：说明操作正常完成之后，数据结构的变化状况和应返回的结果。
		   
```

eg:**1.Circle的定义：**

![](.\images\2_17.png)



**2.复数的定义**

![](.\images\2_18.png)

![](.\images\2_20.png)



#### 1.3.抽象数据类型的表示和实现

##### 前面概念小结

![](.\images\3_1.png)

![](.\images\3_2.png)



##### 1.抽象数据类型的实现

此课程用C语言来实现抽象数据结构，描述它的存储结构。

![](.\images\3_4.png)

- 抽象数据类型可以通过固有的数据类型(如整型、实型、字符型等)来表示和实现。即利用处理器中已存在的数据类型来说明新的结构，用已经实现的操作来组合新的操作。

注:在本门课程的学习过程中，我们使用的**类C语言**(介于伪码和C语言之间)作为描述工具。其描述语法见教材P10-11。但上机时要用具体语言实现，如C、C++等

**eg:抽象数据类型“复数”的实现**

```c
typedef struct{
		float realpart;/*实部*/
		float imagpart;/*虚部*/
}Complex			   /*定义复数抽象类型*/

void assign(Complex *A, float real, float imag);/*赋值*/
void add (Complex * A, float real , float imag);/*A＋B*/
void minus (Complex * A, float real , float imag);/*A-B*/
void multiply (Complex * A, float real , float imag);/*A*B*/
void divide (Complex * A, float real , float imag);/*A/B*/
```

```c
void assign (Complex tA,float real, float imag){
	A->realpart = real;/*实部赋值*/
	A->imagpart= imag;/*虚部赋值*/
}					  /*End of assign()*/

void add(Complex *c,Complex A,Complex B){/*c = A+B*/
	c->realpart=A.realpart+B.realpart;/*实部相加*/
	c->imagpart=A.imagpar+B.imagpart;    /*虚部相加*/
}	/*End of Add()*/

```

![](.\images\3_5.png)



#### 1.4 算法和算法分析

##### 1.定义：

![](.\images\4_1.png)

算法描述方式一：自然语言

![](.\images\4_2.png)

算法描述方法二：传统流程图

![](.\images\4_3.png)

算法描述方法三：NS流程图

![](.\images\4_4.png)

算法描述方法四：伪代码：类C语言

算法描述方法五：程序语言。



##### 2.算法与程序关系

![](.\images\4_5.png)



##### 3.算法的特性

![](.\images\4_6.png)

##### 4.算法设计要求

![](.\images\4_7.png)

**1.正确性：**

![](.\images\4_11.png)

**2.可读性**

![](.\images\4_10.png)

**3.健壮性**

![](.\images\4_12.png)

**具有很好的鲁棒性**

**4.高效性**

![](.\images\4_13.png)



**5.算法的分析与评价**

![](.\images\4_14.png)

![](.\images\4_16.png)

根据问题需求来综合权衡时间效率和空间效率

**算法时间效率的度量**

![](.\images\4_17.png)

更多选用事前分析

##### 5.事前分析方法

![](.\images\4_20.png)

![](.\images\4_21.png)

![](.\images\4_22.png)

![](.\images\4_23.png)

![](.\images\4_24.png)

eg:

![](.\images\4_25.png)

![](.\images\4_28.png)

计算太过复杂，可以通过比较数量级即可

##### 6.算法时间复杂度的渐近表示法

![](.\images\4_29.png)

T1是2次方，T2是三次方，所以T1好

![](.\images\4_30.png)

![](.\images\4_31.png)

**算法时间复杂度定义**：

![](.\images\4_33.png)

**基本语句的确定**：

![](.\images\4_34.png)

**问题规模的确定**：

![](.\images\4_35.png)



##### 7.分析算法时间复杂度的基本方法（重点）

![](.\images\4_36.png)

![](.\images\4_37.png)

**方法步骤**：

![](.\images\4_38.png)

eg:1.

![](.\images\4_39.png)

2.

![](.\images\4_40.png)

![](.\images\4_41.png)



3.

![](.\images\4_42.png)

级数求和计算

4.

![](.\images\4_43.png)



5.

![](.\images\4_44.png)

![](.\images\4_46.png)



##### 8.算法复杂度计算

![](.\images\4_48.png)

**时间复杂度分别考虑**：

![](.\images\4_49.png)

![](.\images\4_50.png)

**算法时间效率比较**

![](.\images\4_52.png)



##### 9.度量算法的空间效率——渐近空间复杂度

![](.\images\4_53.png)

eg:将一组数组a的n个数逆序存放到原数组中。

![](.\images\4_54.png)

![](.\images\4_55.png)



##### 10.总结——设计好算法的过程

![](.\images\4_56.png)



### 第二章

#### 2.1线性表的定义和特点

![](.\images\5_1.png)

![](.\images\5_2.png)

##### 1.定义和特点

线性表是具有相同特性的数据元素的一个有限序列

![](.\images\5_3.png)

![](.\images\5_4.png)

eg:分析26个英文字母组成的英文表

(A,B,C,D.......,Z)

![](.\images\5_5.png)

2.

![](.\images\5_6.png)

3.

![](.\images\5_8.png)



**线性表的逻辑特征**

![](.\images\5_9.png)

线性表是一种典型的线性结构



#### 2.2.线性表的典型应用案例

##### 1.一元多项式的运算：实现两个多项式加、减、乘运算

![](.\images\6_1.png)

![](.\images\6_2.png)

![](.\images\6_3.png)

![](.\images\6_4.png)



##### 2.稀疏多项式的运算

![](.\images\6_5.png)

![](.\images\6_6.png)

![](.\images\6_7.png)

![](.\images\6_8.png)

![](.\images\6_9.png)



##### 3.图书信息管理系统

![](.\images\6_10.png)

![](.\images\6_12.png)

![](.\images\6_13.png)



#### 2.3.线性表的类型定义

![](.\images\6_14.png)

![](.\images\6_15.png)

![](.\images\6_16.png)

![](.\images\6_17.png)

![](.\images\6_18.png)

![](.\images\6_19.png)

![](.\images\6_21.png)

![](.\images\6_22.png)





#### 2.4 线性表的顺序存储

![](.\images\7_1.png)

![](.\images\7_2.png)

![](.\images\7_3.png)

![](.\images\7_4.png)

![](.\images\7_5.png)

![](.\images\7_6.png)

![](.\images\7_7.png)

![](.\images\7_8.png)

![](.\images\7_8.png)

![](.\images\7_11.png)

![](.\images\7_12.png)

![](.\images\7_13.png)

![](.\images\7_14.png)



#### 2.5 线性表的链式表示和实现

![](.\images\8_1.png)

1.补充算法——判断链表为空

![](.\images\8_2.png)

2.补充算法——单链表的销毁

![](.\images\8_3.png)

![](.\images\8_5.png)

![](.\images\8_6.png)

![](.\images\8_7.png)

![](.\images\8_8.png)



补充算法——清空链表

![](.\images\8_11.png)

![](.\images\8_12.png)

补充算法——求链表表长

![](.\images\8_13.png)

![](.\images\8_14.png)